///////////////////////////////////////////////////////////////////////////////
//
// Using the PEB and TEB to navigate loaded modules and such trickery
//
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2021-2023 Oliver Schneider (assarbad.net)
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// [Boost Software License - Version 1.0 - August 17th, 2003]
//
// SPDX-License-Identifier: BSL-1.0
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __NTPEBLDR_H_VER__
#define __NTPEBLDR_H_VER__ 2023073123
#if !NTPEBLDR_NO_PRAGMA_ONCE && ((defined(_MSC_VER) && (_MSC_VER >= 1020)) || defined(__MCPP))
#    pragma once
#endif
#if defined(__cplusplus) && defined(_MSVC_LANG) && (__cplusplus == 199711L)
static_assert(_MSVC_LANG >= 201703L, "This header expects a C++17 compatible compiler.");
#else
static_assert(__cplusplus >= 201703L, "This header expects a C++17 compatible compiler.");
#endif
#if defined(WIN32_NO_STATUS)
#    undef _NTSTATUS_
#    undef WIN32_NO_STATUS
#endif
#pragma warning(disable : 4005)
#include <ntstatus.h>
#pragma warning(default : 4005)
#include <winternl.h>

#ifndef NTPEBLDR_LITERAL_UNICODE_STRING
#    define NTPEBLDR_LITERAL_UNICODE_STRING(s)                            \
        {                                                                 \
            sizeof(s) - sizeof(s[0]), sizeof(s), const_cast<PWSTR>(L"" s) \
        }
#endif // NTPEBLDR_LITERAL_UNICODE_STRING

#ifndef NTPEBLDR_LOCAL_PEBTEB_STRUCT
#    define NTPEBLDR_LOCAL_PEBTEB_STRUCT 1
#endif
#ifndef NTPEBLDR_NAIVE_CRT_INLINES
#    define NTPEBLDR_NAIVE_CRT_INLINES 1
#endif
#ifndef STATIC_INLINE
#    ifdef _MSC_VER
#        define STATIC_INLINE static __forceinline
#    else
#        define STATIC_INLINE static inline
#    endif // _MSC_VER
#endif     // STATIC_INLINE
#if !NTPEBLDR_NAIVE_CRT_INLINES
#    include <cstdio> // towupper/towlower et. al.
#endif
#include <cstddef> // offsetof etc
#if defined(NTPEBLDR_PRINT_FUNCS) || defined(_DEBUG)
#    include <tchar.h>
#endif // _DEBUG

namespace NT
{
// Must correspond to IMAGE_DYNAMIC_RELOCATION_MM_SHARED_USER_DATA_VA from km/ntimage.h
// Kernel mode address is KI_USER_SHARED_DATA (on ARM64 this is relocatable!)
#if defined(_WIN32) && (defined(_M_IX86) || defined(_M_AMD64))
#    ifndef MM_SHARED_USER_DATA_VA
#        define MM_SHARED_USER_DATA_VA                          ((unsigned char*)0x7ffe0000)
#        define IMAGE_DYNAMIC_RELOCATION_MM_SHARED_USER_DATA_VA MM_SHARED_USER_DATA_VA
#    endif
    namespace
    {
        WCHAR const (&SystemRoot)[260] = (decltype(SystemRoot))(*(WCHAR*)(MM_SHARED_USER_DATA_VA + 0x30));
        USHORT const& NativeProcessorArchitecture = *((USHORT*)(MM_SHARED_USER_DATA_VA + 0x026a));
        ULONG const& MajorVersion = *((ULONG*)(MM_SHARED_USER_DATA_VA + 0x026c));
        ULONG const& MinorVersion = *((ULONG*)(MM_SHARED_USER_DATA_VA + 0x0270));
    } // namespace
#endif

    using byte = unsigned char;

    typedef struct _LDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY InLoadOrderModuleList;
        LIST_ENTRY InMemoryOrderModuleList;
        LIST_ENTRY InInitializationOrderModuleList;
        PVOID DllBase;
        PVOID EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
        ULONG Flags;
        USHORT ObsoleteLoadCount;
        USHORT TlsIndex;
        LIST_ENTRY HashLinks;
        ULONG TimeDateStamp;
        PVOID EntryPointActivationContext;
        PVOID Lock;
    } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
    static_assert(offsetof(LDR_DATA_TABLE_ENTRY, DllBase) == 3 * sizeof(LIST_ENTRY), "DllBase offset has unexpected value");

    typedef struct
    {
        PVOID DllBase;
        PVOID EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
        ULONG Flags;
    } LDR_DATA_TABLE_ENTRY_CTX, *PLDR_DATA_TABLE_ENTRY_CTX;

    namespace Glue
    {
        typedef struct
        {
            LIST_ENTRY InLoadOrderModuleList;
            LIST_ENTRY InMemoryOrderModuleList;
            LIST_ENTRY InInitializationOrderModuleList;
            union
            {
                LDR_DATA_TABLE_ENTRY_CTX context;
                struct
                {
                    PVOID DllBase;
                    PVOID EntryPoint;
                    ULONG SizeOfImage;
                    UNICODE_STRING FullDllName;
                    UNICODE_STRING BaseDllName;
                    ULONG Flags;
                    USHORT ObsoleteLoadCount;
                    USHORT TlsIndex;
                    LIST_ENTRY HashLinks;
                    ULONG TimeDateStamp;
                    PVOID EntryPointActivationContext;
                    PVOID Lock;
                } real;
            } tail;
        } LDR_DATA_TABLE_ENTRY;
    } // namespace Glue
    static_assert(sizeof(Glue::LDR_DATA_TABLE_ENTRY) == sizeof(LDR_DATA_TABLE_ENTRY), "These two must match");
    static_assert(offsetof(LDR_DATA_TABLE_ENTRY, Flags) == offsetof(Glue::LDR_DATA_TABLE_ENTRY, tail.real.Flags), "DllBase offset has unexpected value");
    static_assert(offsetof(Glue::LDR_DATA_TABLE_ENTRY, tail.context.Flags) == offsetof(Glue::LDR_DATA_TABLE_ENTRY, tail.real.Flags),
                  "DllBase offset has unexpected value");

    typedef struct _PEB_LDR_DATA
    {
        ULONG Length;
        BOOLEAN Initialized;
        HANDLE SsHandle;
        LIST_ENTRY InLoadOrderModuleList;
        LIST_ENTRY InMemoryOrderModuleList;
        LIST_ENTRY InInitializationOrderModuleList;
        PVOID EntryInProgress;
        BOOLEAN ShutdownInProgress;
        HANDLE ShutdownThreadId;
    } PEB_LDR_DATA, *PPEB_LDR_DATA;

#if NTPEBLDR_LOCAL_PEBTEB_STRUCT
    typedef struct // xref: http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB_combined.html
    {
        NT_TIB NtTib;
        PVOID EnvironmentPointer;
        CLIENT_ID ClientId;
        PVOID ActiveRpcHandle;
        PVOID ThreadLocalStoragePointer;
        PPEB ProcessEnvironmentBlock;
        ULONG LastErrorValue;
        ULONG CountOfOwnedCriticalSections;
        PVOID CsrClientThread;
        PVOID Win32ThreadInfo;
        ULONG User32Reserved[26];
        ULONG UserReserved[5];
        PVOID WOW32Reserved;
        LCID CurrentLocale;
        ULONG FpSoftwareStatusRegister;
        PVOID ReservedForDebuggerInstrumentation[16];
        PVOID SystemReserved1[38];
        NTSTATUS ExceptionCode;
#    ifdef _M_X64
        ULONG UnknownAndDontCare[0x55D];
#    elif defined(_M_IX86)
        ULONG UnknownAndDontCare[0x396];
#    endif // _M_X64
           // Padding up to size 0x1838
    } TEB, *PTEB;
#    ifdef _M_X64
    static_assert(sizeof(TEB) == 0x1838, "Expected size to be a fixed, known value");
#    elif defined(_M_IX86)
    static_assert(sizeof(TEB) == 0x1000, "Expected size to be a fixed, known value");
#    endif // _M_X64

#    pragma warning(disable : 4201)
    typedef struct // xref: http://terminus.rewolf.pl/terminus/structures/ntdll/_PEB_combined.html
    {
        BOOLEAN InheritedAddressSpace;
        BOOLEAN ReadImageFileExecOptions;
        BOOLEAN BeingDebugged;
        union
        {
            BOOLEAN BitField;
            struct
            {
                BOOLEAN ImageUsesLargePages : 1;
                BOOLEAN IsProtectedProcess : 1;
                BOOLEAN IsImageDynamicallyRelocated : 1;
                BOOLEAN SkipPatchingUser32Forwarders : 1;
                BOOLEAN IsPackagedProcess : 1;
                BOOLEAN IsAppContainer : 1;
                BOOLEAN IsProtectedProcessLight : 1;
                BOOLEAN IsLongPathAwareProcess : 1; // xref: https://stackoverflow.com/a/57091811
            };
        };
        HANDLE Mutant;
        PVOID ImageBaseAddress;
        PPEB_LDR_DATA Ldr;
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
        PVOID SubSystemData;
        PVOID ProcessHeap;
        PRTL_CRITICAL_SECTION FastPebLock;
        PSLIST_HEADER AtlThunkSListPtr;
        // Everything from here down has been copied from winternl.h for now
        PVOID Reserved5;
        ULONG Reserved6;
        PVOID Reserved7;
        ULONG Reserved8;
        ULONG AtlThunkSListPtr32;
        PVOID Reserved9[45];
        BYTE Reserved10[96];
        PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
        BYTE Reserved11[128];
        PVOID Reserved12[1];
        ULONG SessionId;
    } PEB, *PPEB;
#    pragma warning(default : 4201)
#endif // NTPEBLDR_LOCAL_PEBTEB_STRUCT

    template <typename> struct NTSTRING
    {
    };
    template <> struct NTSTRING<WCHAR>
    {
        typedef UNICODE_STRING string_type;
        typedef WCHAR char_type;
    };
    template <> struct NTSTRING<CHAR>
    {
        typedef ANSI_STRING string_type;
        typedef CHAR char_type;
    };
    template <> struct NTSTRING<UNICODE_STRING>
    {
        typedef UNICODE_STRING string_type;
        typedef WCHAR char_type;
    };
    template <> struct NTSTRING<ANSI_STRING>
    {
        typedef ANSI_STRING string_type;
        typedef CHAR char_type;
    };
    template <typename T> using strchar_t = typename NTSTRING<T>::char_type;
    template <typename T> using strtype_t = typename NTSTRING<T>::string_type;

    // Just to avoid pulling in type_traits header for this
    template <typename, typename> constexpr bool is_same_v = false;
    template <typename T> constexpr bool is_same_v<T, T> = true;

    inline namespace ntdll
    {
        STATIC_INLINE TEB* NtCurrentTeb()
        {
#if defined(_WIN64) && defined(_M_X64)
            return (TEB*)__readgsqword(0x30);
#elif defined(_WIN32) && defined(_M_IX86)
            return (TEB*)__readfsdword(0x18);
#else
#    error This isn't currently implemented on the current platform, it seems. Review the code, implement it and retry.
#endif
        }

        STATIC_INLINE PEB* RtlGetCurrentPeb() // officially with winver>=5.1
        {
#if defined(_WIN64) && defined(_M_X64)
            return (PEB*)__readgsqword(0x60);
#elif defined(_WIN32) && defined(_M_IX86)
            return (PEB*)__readfsdword(0x30);
#else
            return NtCurrentTeb()->ProcessEnvironmentBlock;
#endif
        }

        // Reimplementation of a few functions we don't want to import
        namespace crt
        {
            STATIC_INLINE size_t strlen_(char const* str)
            {
                if (!str)
                    return 0;
                size_t idx;
                for (idx = 0; str[idx]; idx++)
                    ;
                return idx;
            }

            STATIC_INLINE size_t wcslen_(wchar_t const* str)
            {
                if (!str)
                    return 0;
                size_t idx;
                for (idx = 0; str[idx]; idx++)
                    ;
                return idx;
            }

            STATIC_INLINE int strncmp_(char const* s1, char const* s2, size_t len)
            {
                if ((!s1 && !s2) || !len)
                {
                    return 0;
                }
                byte const* bs1 = (byte*)s1;
                byte const* bs2 = (byte*)s2;
                for (size_t idx = 0; idx <= len; idx++)
                {
                    auto const& b1 = bs1[idx];
                    auto const& b2 = bs2[idx];
                    if (b1 != b2)
                    {
                        return b1 - b2;
                    }
                    if (('\0' == b1) || ('\0' == b2))
                    {
                        return b1 - b2;
                    }
                }
                return 0;
            }

            STATIC_INLINE int wcsncmp_(wchar_t const* s1, wchar_t const* s2, size_t len)
            {
                if ((!s1 && !s2) || !len)
                {
                    return 0;
                }
                unsigned short const* bs1 = (unsigned short*)s1;
                unsigned short const* bs2 = (unsigned short*)s2;
                for (size_t idx = 0; idx <= len; idx++)
                {
                    auto const& b1 = bs1[idx];
                    auto const& b2 = bs2[idx];
                    if (b1 != b2)
                    {
                        return b1 - b2;
                    }
                    if ((L'\0' == b1) || (L'\0' == b2))
                    {
                        return b1 - b2;
                    }
                }
                return 0;
            }

#if NTPEBLDR_NAIVE_CRT_INLINES
            // Certainly naive and incomplete, but in all likelihood more than sufficient
            // for most purposes we're after here
            STATIC_INLINE WCHAR towlower_(WCHAR ch)
            {
                if ((L'A' <= ch) && (ch <= L'Z'))
                    ch += 0x20;
                return ch;
            }
            STATIC_INLINE WCHAR towupper_(WCHAR ch)
            {
                if ((L'a' <= ch) && (ch <= L'z'))
                    ch -= 0x20;
                return ch;
            }
            STATIC_INLINE CHAR tolower_(CHAR ch)
            {
                if (('A' <= ch) && (ch <= 'Z'))
                    ch += 0x20;
                return ch;
            }
            STATIC_INLINE CHAR toupper_(CHAR ch)
            {
                if (('a' <= ch) && (ch <= 'z'))
                    ch -= 0x20;
                return ch;
            }
#else
            // The right side is _intentionally_ without namespace, so a preprocessor
            // define could still be used to point these elsewhere ...
            wint_t (*towlower_)(wint_t) = towlower;
            wint_t (*towupper_)(wint_t) = towupper;
            int (*tolower_)(int) = tolower;
            int (*toupper_)(int) = toupper;
#endif

            template <class...> constexpr bool always_false_v = false;

            template <typename CHARTYPE> STATIC_INLINE CHARTYPE toupper(CHARTYPE ch)
            {
                if constexpr (is_same_v<CHARTYPE, WCHAR>)
                {
                    return (CHARTYPE)towupper_((CHARTYPE)ch);
                }
                else if constexpr (is_same_v<CHARTYPE, CHAR>)
                {
                    return (CHARTYPE)toupper_((CHARTYPE)ch);
                }
                else
                {
                    static_assert(always_false_v<CHARTYPE>, "Not supported for whatever character type this is");
                }
            }

            template <typename CHARTYPE> STATIC_INLINE CHARTYPE tolower(CHARTYPE ch)
            {
                if constexpr (is_same_v<CHARTYPE, WCHAR>)
                {
                    return (CHARTYPE)towlower_((CHARTYPE)ch);
                }
                else if constexpr (is_same_v<CHARTYPE, CHAR>)
                {
                    return (CHARTYPE)tolower_((CHARTYPE)ch);
                }
                else
                {
                    static_assert(always_false_v<CHARTYPE>, "Not supported for whatever character type this is");
                }
            }

            // This is not exactly optimized, but should be a halfway faithful implementation of the original functionality
            template <typename STRTYPE> STATIC_INLINE LONG CompareString(STRTYPE const& String1, STRTYPE const& String2, BOOLEAN CaseInSensitive)
            {
                using CHARTYPE = strchar_t<STRTYPE>;
                CHARTYPE* str1 = String1.Buffer;
                CHARTYPE* str2 = String2.Buffer;
                LONG const len1 = String1.Length / sizeof(CHARTYPE);
                LONG const len2 = String2.Length / sizeof(CHARTYPE);
                LONG const minlen = (len1 <= len2) ? len1 : len2;

                if (CaseInSensitive)
                {
                    for (LONG idx = 0; idx < minlen; idx++)
                    {
                        if (str1[idx] != str2[idx])
                        {
                            auto const c1 = toupper(str1[idx]);
                            auto const c2 = toupper(str2[idx]);
                            if (c1 != c2)
                            {
                                return (LONG)c1 - (LONG)c2;
                            }
                        }
                    }
                }
                else
                {
                    for (LONG idx = 0; idx < minlen; idx++)
                    {
                        if (str1[idx] != str2[idx])
                        {
                            return (LONG)str1[idx] - (LONG)str2[idx];
                        }
                    }
                }
                return len1 - len2;
            }
        } // namespace crt

        STATIC_INLINE LONG RtlCompareUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive)
        {
            return crt::CompareString(*String1, *String2, CaseInSensitive);
        }

        STATIC_INLINE LONG RtlCompareString(PCANSI_STRING String1, PCANSI_STRING String2, BOOLEAN CaseInSensitive)
        {
            return crt::CompareString(*String1, *String2, CaseInSensitive);
        }

        // This is not exactly optimized, but should be a halfway faithful implementation of the original functionality
        STATIC_INLINE VOID RtlInitUnicodeString(PUNICODE_STRING DestinationString, LPCWSTR SourceString)
        {
            DestinationString->Buffer = const_cast<LPWSTR>(SourceString);
            if (SourceString)
            {
                size_t const idx = ntdll::crt::wcslen_(SourceString);
                // TBD: should we check against 0x8000? Does the actual ntdll implementation do it?
                DestinationString->Length = (USHORT)idx * sizeof(SourceString[idx]);
                DestinationString->MaximumLength = DestinationString->Length + sizeof(SourceString[idx]);
            }
            else
            {
                DestinationString->Length = DestinationString->MaximumLength = 0;
            }
        }

        STATIC_INLINE DWORD RtlGetLastWin32Error()
        {
#if NTPEBLDR_LOCAL_PEBTEB_STRUCT
            return NtCurrentTeb()->LastErrorValue;
#else
            auto const* pdwLastError = (DWORD*)((byte*)&NtCurrentTeb()->ProcessEnvironmentBlock + sizeof(PVOID));
            return *pdwLastError;
#endif // NTPEBLDR_LOCAL_PEBTEB_STRUCT
        }

        STATIC_INLINE void RtlSetLastWin32Error(DWORD LastError) // the real implementation does a little more, and includes a debug helper
        {
#if NTPEBLDR_LOCAL_PEBTEB_STRUCT
            NtCurrentTeb()->LastErrorValue = LastError;
#else
            auto* pdwLastError = (DWORD*)((byte*)&NtCurrentTeb()->ProcessEnvironmentBlock + sizeof(PVOID));
            *pdwLastError = LastError;
#endif // NTPEBLDR_LOCAL_PEBTEB_STRUCT
        }

    } // namespace ntdll

    inline namespace util
    {
        template <typename CHARTYPE, size_t MaxLength>
        STATIC_INLINE constexpr strtype_t<CHARTYPE> const InitString(CHARTYPE const (&str)[MaxLength], USHORT ActualLength)
        {
            static_assert(MaxLength == sizeof(str) / sizeof(str[0]), "Well, crap ...");
            return {ActualLength, sizeof(str), const_cast<CHARTYPE*>(&str[0])};
        }

        template <typename CHARTYPE, size_t MaxLength> STATIC_INLINE constexpr strtype_t<CHARTYPE> const InitString(CHARTYPE const (&str)[MaxLength])
        {
            return InitString(str, sizeof(str) - sizeof(str[0]));
        }

        template <typename STRTYPE> constexpr STATIC_INLINE size_t StringEndsWith(STRTYPE const& String, STRTYPE const& Suffix, BOOLEAN CaseInSensitive = TRUE)
        {
            size_t const Offset = (String.Length / sizeof(String.Buffer[0])) - (Suffix.Length / sizeof(Suffix.Buffer[0]));
            STRTYPE const sSuspectedSuffix = {Suffix.Length, Suffix.MaximumLength, &String.Buffer[Offset]};
            return (0 == ntdll::crt::CompareString(Suffix, sSuspectedSuffix, CaseInSensitive)) ? Offset : 0;
        }

        template <typename CHARTYPE, size_t Length, typename STRTYPE = strtype_t<CHARTYPE>>
        constexpr STATIC_INLINE size_t StringEndsWith(STRTYPE const& String, CHARTYPE const (&Suffix)[Length], BOOLEAN CaseInSensitive = TRUE)
        {
            STRTYPE const sSuffix = InitString(Suffix);
            return StringEndsWith(String, sSuffix, CaseInSensitive);
        }

        template <typename STRTYPE>
        constexpr STATIC_INLINE STRTYPE TruncateStringAt(STRTYPE const& String, STRTYPE const& Suffix, BOOLEAN CaseInSensitive = TRUE)
        {
            auto const Offset = StringEndsWith(String, Suffix, CaseInSensitive);
            if (!Offset)
            {
                return String;
            }
            USHORT const NewLength = (USHORT)((USHORT)Offset * sizeof(String.Buffer[0]));
            USHORT const Difference = (String.Length - NewLength);
            STRTYPE const sRetVal = {NewLength, (USHORT)(String.MaximumLength - Difference), String.Buffer};
            return sRetVal;
        }

        template <typename CHARTYPE, size_t Length, typename STRTYPE = strtype_t<CHARTYPE>>
        constexpr STATIC_INLINE STRTYPE TruncateStringAt(STRTYPE const& String, CHARTYPE const (&Suffix)[Length], BOOLEAN CaseInSensitive = TRUE)
        {
            STRTYPE const sSuffix = InitString(Suffix);
            return TruncateStringAt(String, sSuffix, CaseInSensitive);
        }

    } // namespace util

    STATIC_INLINE PEB_LDR_DATA* GetPebLdr()
    {
        PEB* peb = ntdll::RtlGetCurrentPeb();
        if (peb)
        {
            return (PEB_LDR_DATA*)peb->Ldr;
        }
        return nullptr;
    }

    enum class PebLdrOrder : unsigned char
    {
        load,
        memory,
        init,
    };

    STATIC_INLINE LIST_ENTRY const* GetPebLdrListHead(PEB_LDR_DATA const* ldrdata, PebLdrOrder order)
    {
        if (!ldrdata)
        {
            return nullptr;
        }
        switch (order)
        {
        case PebLdrOrder::load:
            return ldrdata->InLoadOrderModuleList.Flink;
        case PebLdrOrder::memory:
            return ldrdata->InMemoryOrderModuleList.Flink;
        case PebLdrOrder::init:
            return ldrdata->InInitializationOrderModuleList.Flink;
        }
        return nullptr;
    }

    STATIC_INLINE LIST_ENTRY const* GetPebLdrListHead(PebLdrOrder order)
    {
        PEB_LDR_DATA const* ldrdata = GetPebLdr();
        return GetPebLdrListHead(ldrdata, order);
    }

    STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataTableEntry(LIST_ENTRY const* current, PebLdrOrder order)
    {
        switch (order)
        {
        case PebLdrOrder::load:
            return CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
        case PebLdrOrder::memory:
            return CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);
        case PebLdrOrder::init:
            return CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InInitializationOrderModuleList);
        }
        return nullptr;
    }

    STATIC_INLINE LDR_DATA_TABLE_ENTRY_CTX const* GetLdrDataTableEntryPredicateContext(LIST_ENTRY const* current, PebLdrOrder order)
    {
        auto const* entry = GetLdrDataTableEntry(current, order);
        if (entry)
        {
            return &((Glue::LDR_DATA_TABLE_ENTRY*)entry)->tail.context;
        }
        return nullptr;
    }

    template <typename T, PebLdrOrder order_v> struct callback
    {
        static PebLdrOrder const order = order_v;
        using data_t = T;
        using func_t = NTSTATUS(CALLBACK*)(LDR_DATA_TABLE_ENTRY_CTX const&, LDR_DATA_TABLE_ENTRY const*, T&);
    };

    template <typename T, PebLdrOrder order_v> using cbfunc_t = typename callback<T, order_v>::func_t;
    template <typename T, PebLdrOrder order_v> using cbdata_t = typename callback<T, order_v>::data_t;

    template <typename T, PebLdrOrder order_v = PebLdrOrder::load>
    STATIC_INLINE NTSTATUS IteratePebLdrDataTable(cbfunc_t<T, order_v> predicate, cbdata_t<T, order_v>& context)
    {
        constexpr PebLdrOrder const order = callback<T, order_v>::order;
        auto const* first = GetPebLdrListHead(order);

        if (!first)
        {
            return STATUS_INVALID_HANDLE;
        }
        auto const* current = first;

        do
        {
            auto const* tblentry = GetLdrDataTableEntryPredicateContext(current, order);
            auto const* curr_entry = GetLdrDataTableEntry(current, order);
            NTSTATUS Status;
            if (STATUS_NOT_FOUND != (Status = predicate(*tblentry, curr_entry, context)))
            {
                return Status;
            }
            current = current->Flink;
        } while (current != first);
        return STATUS_NO_MORE_ENTRIES; // we've reached the list end
    }

#if defined(NTPEBLDR_PRINT_FUNCS) || defined(_DEBUG)
    inline namespace print_helpers
    {
        STATIC_INLINE void print_ldr_entry_ctx(LDR_DATA_TABLE_ENTRY_CTX const& ldrctx, bool skip_terminator = true)
        {
            if (skip_terminator && !ldrctx.DllBase && !ldrctx.SizeOfImage && !ldrctx.EntryPoint && !ldrctx.Flags && !ldrctx.BaseDllName.Buffer)
            {
                return;
            }
            _tprintf(_T("  PVOID DllBase = @%p;\n"), ldrctx.DllBase);
            _tprintf(_T("  PVOID EntryPoint = @%p;\n"), ldrctx.EntryPoint);
            _tprintf(_T("  ULONG SizeOfImage = %u (0x%08X);\n"), ldrctx.SizeOfImage, ldrctx.SizeOfImage);

            _tprintf(_T("  UNICODE_STRING FullDllName = \"%wZ\";\n"), &ldrctx.FullDllName);
            _tprintf(_T("  UNICODE_STRING BaseDllName = \"%wZ\";\n"), &ldrctx.BaseDllName);

            _tprintf(_T("  ULONG Flags = 0x%08X);\n"), ldrctx.Flags);
        }

        STATIC_INLINE void print_ldr_entry(LDR_DATA_TABLE_ENTRY const& ldrentry, bool nolinks = false)
        {
            _tprintf(_T("((LDR_DATA_TABLE_ENTRY*)@%p)\n"), &ldrentry);

            if (!nolinks)
            {
                _tprintf(_T("  LIST_ENTRY InLoadOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrentry.InLoadOrderModuleList.Flink,
                         ldrentry.InLoadOrderModuleList.Blink);
                _tprintf(_T("  LIST_ENTRY InMemoryOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrentry.InMemoryOrderModuleList.Flink,
                         ldrentry.InMemoryOrderModuleList.Blink);
                _tprintf(_T("  LIST_ENTRY InInitializationOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrentry.InInitializationOrderModuleList.Flink,
                         ldrentry.InInitializationOrderModuleList.Blink);
            }

            auto const& ldrctx = ((Glue::LDR_DATA_TABLE_ENTRY*)&ldrentry)->tail.context;
            print_ldr_entry_ctx(ldrctx);

            _tprintf(_T("  ULONG TimeDateStamp = 0x%08X;\n"), ldrentry.TimeDateStamp);
        }

        STATIC_INLINE void print_linked_list(LIST_ENTRY const* first, PebLdrOrder order, BOOLEAN bShowFullName = FALSE)
        {
            auto const* current = first;
            ULONG idx = 0;
            do
            {
                auto const* e = GetLdrDataTableEntryPredicateContext(current, order);
                if (e && e->DllBase && e->SizeOfImage && e->BaseDllName.Buffer && e->FullDllName.Buffer)
                {
                    _tprintf(
                        _T("    [% 2u] @%p, %wZ: s = %u, f = 0x%08X, ep = @%p\n"), idx, e->DllBase, &e->BaseDllName, e->SizeOfImage, e->Flags, e->EntryPoint);
                    if (bShowFullName)
                    {
                        _tprintf(_T("         %wZ\n"), &e->FullDllName);
                    }
                }
                current = current->Flink;
                idx++;
            } while (current != first);
        }

        STATIC_INLINE void print_ldr_data(PEB_LDR_DATA const& ldrdata, bool nolinks = false)
        {
            _tprintf(_T("((PEB_LDR_DATA*)@%p)\n"), &ldrdata);

            _tprintf(_T("  ULONG Length = %u (0x%08X);\n"), ldrdata.Length, ldrdata.Length);
            _tprintf(_T("  BOOLEAN Initialized = %u;\n"), ldrdata.Initialized);
            _tprintf(_T("  HANDLE SsHandle = @%p;\n"), ldrdata.SsHandle);

            if (!nolinks)
            {
                _tprintf(_T("  LIST_ENTRY InLoadOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrdata.InLoadOrderModuleList.Flink,
                         ldrdata.InLoadOrderModuleList.Blink);
                print_linked_list(ldrdata.InLoadOrderModuleList.Flink, PebLdrOrder::load);
                _tprintf(_T("  LIST_ENTRY InMemoryOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrdata.InMemoryOrderModuleList.Flink,
                         ldrdata.InMemoryOrderModuleList.Blink);
                print_linked_list(ldrdata.InMemoryOrderModuleList.Flink, PebLdrOrder::memory);
                _tprintf(_T("  LIST_ENTRY InInitializationOrderModuleList = {Flink = @%p, Blink = @%p};\n"),
                         ldrdata.InInitializationOrderModuleList.Flink,
                         ldrdata.InInitializationOrderModuleList.Blink);
                print_linked_list(ldrdata.InInitializationOrderModuleList.Flink, PebLdrOrder::init);
            }
        }
    } // namespace print_helpers
#endif

    STATIC_INLINE NT::LDR_DATA_TABLE_ENTRY const* GetNtDllEntry()
    {
        constexpr PebLdrOrder const order = PebLdrOrder::load;
        auto const* head = GetPebLdrListHead(order);
        if (head)
        {
            return GetLdrDataTableEntry(head->Flink, order);
        }
        return nullptr;
    }

    STATIC_INLINE HMODULE GetNtDll()
    {
        auto const* ldrentry = GetNtDllEntry();
        if (ldrentry)
        {
            return (HMODULE)ldrentry->DllBase;
        }
        return nullptr;
    }

    STATIC_INLINE UNICODE_STRING GetNtDllDirectory()
    {
        auto const* ntdll = GetNtDllEntry();
        if (ntdll)
        {
            return TruncateStringAt(ntdll->FullDllName, ntdll->BaseDllName, TRUE);
        }
        return {};
    }

    namespace predefined_helpers
    {
        namespace by_order
        {
            typedef struct _MapByOrder
            {
                ULONG IndexToBeIncremented; // incremented inside the callback
                ULONG IndexToLookFor;
                PVOID DllBase;
                LDR_DATA_TABLE_ENTRY const* LdrDataTableEntry;
            } MapByOrder;

            STATIC_INLINE NTSTATUS CALLBACK MapOrderPredicate(LDR_DATA_TABLE_ENTRY_CTX const& ldrctx,
                                                              LDR_DATA_TABLE_ENTRY const* ldrdataentry,
                                                              MapByOrder& data)
            {
                if (ldrctx.DllBase && ldrctx.SizeOfImage && (data.IndexToLookFor == data.IndexToBeIncremented))
                {
                    data.DllBase = ldrctx.DllBase;
                    data.LdrDataTableEntry = ldrdataentry;
                    return STATUS_SUCCESS;
                }
                data.IndexToBeIncremented++;
                return STATUS_NOT_FOUND;
            }

            template <PebLdrOrder order_v = PebLdrOrder::load> STATIC_INLINE HMODULE GetModHandleByOrderIndex(ULONG Index)
            {
                MapByOrder context = {0, Index, nullptr, nullptr};
                NTSTATUS Status = IteratePebLdrDataTable<MapByOrder, order_v>(MapOrderPredicate, context);
                if (NT_SUCCESS(Status))
                {
                    return (HMODULE)context.DllBase;
                }
                return nullptr;
            }

            template <PebLdrOrder order_v = PebLdrOrder::load> STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByOrderIndex(ULONG Index)
            {
                MapByOrder context = {0, Index, nullptr, nullptr};
                NTSTATUS Status = IteratePebLdrDataTable<MapByOrder, order_v>(MapOrderPredicate, context);
                if (NT_SUCCESS(Status))
                {
                    return context.LdrDataTableEntry;
                }
                return nullptr;
            }
        } // namespace by_order

        namespace by_trait
        {
            typedef struct _MapByTrait
            {
                NTSTATUS Status;
                PVOID Address;
                PVOID DllBase;
                LDR_DATA_TABLE_ENTRY const* LdrDataTableEntry;
                ULONG SizeOfImage;
            } MapByTrait;

            STATIC_INLINE NTSTATUS CALLBACK MapTraitPredicate(LDR_DATA_TABLE_ENTRY_CTX const& ldrctx,
                                                              LDR_DATA_TABLE_ENTRY const* ldrdataentry,
                                                              MapByTrait& data)
            {
                if (ldrctx.DllBase && ldrctx.SizeOfImage && (data.Address || data.DllBase))
                {
                    if ((data.DllBase) && (ldrctx.DllBase == data.DllBase))
                    {
                        if (!data.Address) // No address to look for given?
                        {
                            data.SizeOfImage = ldrctx.SizeOfImage;
                            data.LdrDataTableEntry = ldrdataentry;
                            return data.Status = STATUS_SUCCESS; // Found it!
                        }                                        // fall through into the other check
                    }
                    if (data.Address)
                    {
                        if (data.DllBase && (ldrctx.DllBase != data.DllBase)) // If we were passed a module, does it match?
                        {
                            return STATUS_NOT_FOUND; // Nope, so return failure early (will proceed to next ldr entry)
                        }
                        auto const* needle = (byte*)data.Address;
                        auto const* haystack_start = (byte*)ldrctx.DllBase;
                        auto const* haystack_end = haystack_start + ldrctx.SizeOfImage;
                        if ((needle >= haystack_start) && (needle <= haystack_end))
                        {
                            data.DllBase = ldrctx.DllBase;
                            data.SizeOfImage = ldrctx.SizeOfImage;
                            data.LdrDataTableEntry = ldrdataentry;
                            return data.Status = STATUS_SUCCESS;
                        }
                    }
                }
                return data.Status = STATUS_NOT_FOUND;
            }

            STATIC_INLINE HMODULE GetModHandleByAddress(PVOID Address)
            {
                MapByTrait context = {STATUS_UNSUCCESSFUL, Address, nullptr, nullptr, 0};
                NTSTATUS Status = IteratePebLdrDataTable<MapByTrait>(MapTraitPredicate, context);
                if (NT_SUCCESS(Status))
                {
                    return (HMODULE)context.DllBase;
                }
                return nullptr;
            }

            STATIC_INLINE MapByTrait GetModTraits(HMODULE hMod)
            {
                MapByTrait context = {STATUS_UNSUCCESSFUL, nullptr, hMod, nullptr, 0};
                (void)IteratePebLdrDataTable<MapByTrait>(MapTraitPredicate, context);
                return context;
            }

            STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByModule(HMODULE hMod)
            {
                MapByTrait context = {STATUS_UNSUCCESSFUL, nullptr, hMod, nullptr, 0};
                NTSTATUS Status = IteratePebLdrDataTable<MapByTrait>(MapTraitPredicate, context);
                if (NT_SUCCESS(Status))
                {
                    return context.LdrDataTableEntry;
                }
                return nullptr;
            }

            STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByAddress(PVOID Address)
            {
                MapByTrait context = {STATUS_UNSUCCESSFUL, Address, nullptr, nullptr, 0};
                NTSTATUS Status = IteratePebLdrDataTable<MapByTrait>(MapTraitPredicate, context);
                if (NT_SUCCESS(Status))
                {
                    return context.LdrDataTableEntry;
                }
                return nullptr;
            }
        } // namespace by_trait

        namespace by_string
        {
            typedef struct _MapByUnicodeString
            {
                HMODULE hMod = nullptr;
                UNICODE_STRING const& usMod; // could be name or path
            } MapByUnicodeString;

#ifdef NTPEBLDR_UNDERHANDED
            namespace
            {
                template <size_t Length> STATIC_INLINE void InitDllExt(WCHAR (&DllExt)[Length])
                {
                    constexpr WCHAR NtDllName[] = L"ntdll.dll";
                    auto const* ntdll = GetNtDllEntry();
                    if (!ntdll)
                    {
                        return;
                    }
                    UNICODE_STRING const& usNtDll = ntdll->BaseDllName;
                    size_t const nLength = usNtDll.Length / 2; // this length does NOT include the terminating zero
                    auto const* BaseName = usNtDll.Buffer;
                    auto const& Dot = BaseName[5];
                    if ((nLength == _countof(NtDllName) - 1) && (Dot == L'.'))
                    {
                        for (size_t idx = 1; idx < _countof(DllExt) - 1; idx++)
                        {
                            if (NT::crt::toupper(BaseName[1 + idx]) == NT::crt::toupper(BaseName[5 + idx]))
                            {
                                DllExt[idx] = NT::crt::tolower(BaseName[1 + idx]);
                            }
                        }
                        DllExt[0] = Dot;
                    }
                }
            } // namespace
#endif        // NTPEBLDR_UNDERHANDED

            STATIC_INLINE NTSTATUS CALLBACK MapByBaseDllNamePredicate(LDR_DATA_TABLE_ENTRY_CTX const& ldrctx,
                                                                      LDR_DATA_TABLE_ENTRY const* /*ldrdataentry*/,
                                                                      MapByUnicodeString& data)
            {
                auto const& DllName = ldrctx.BaseDllName;
                if (ldrctx.DllBase && ldrctx.SizeOfImage && DllName.Buffer && DllName.Length)
                {
                    if (0 == ntdll::RtlCompareUnicodeString(&data.usMod, &DllName, TRUE))
                    {
                        data.hMod = (HMODULE)ldrctx.DllBase;
                        return STATUS_SUCCESS;
                    }
#ifdef NTPEBLDR_UNDERHANDED
                    static WCHAR DllExt[5]{};
                    if (!DllExt[0])
                    {
                        InitDllExt(DllExt);
                    }
                    if (!DllExt[0])
                    {
                        return STATUS_NOT_FOUND;
                    }
#else  // NTPEBLDR_UNDERHANDED
                    constexpr WCHAR const DllExt[] = L".dll";
#endif // NTPEBLDR_UNDERHANDED
                    static_assert(_countof(DllExt) == 5, "Must fit exactly '.dll\\0'");
                    UNICODE_STRING const usTruncDllName = TruncateStringAt(DllName, DllExt);
                    if (usTruncDllName.Length != DllName.Length) // small optimization
                    {
                        if (0 == ntdll::RtlCompareUnicodeString(&data.usMod, &usTruncDllName, TRUE))
                        {
                            data.hMod = (HMODULE)ldrctx.DllBase;
                            return STATUS_SUCCESS;
                        }
                    }
                }
                return STATUS_NOT_FOUND;
            }

            STATIC_INLINE NTSTATUS CALLBACK MapByFullDllNamePredicate(LDR_DATA_TABLE_ENTRY_CTX const& ldrctx,
                                                                      LDR_DATA_TABLE_ENTRY const* /*ldrdataentry*/,
                                                                      MapByUnicodeString& data)
            {

                auto const& DllName = ldrctx.FullDllName;
                if (ldrctx.DllBase && ldrctx.SizeOfImage && DllName.Buffer && DllName.Length)
                {
                    if (0 == ntdll::RtlCompareUnicodeString(&data.usMod, &DllName, TRUE))
                    {
                        data.hMod = (HMODULE)ldrctx.DllBase;
                        return STATUS_SUCCESS;
                    }
                }
                return STATUS_NOT_FOUND;
            }

            template <typename CTX, cbfunc_t<CTX, PebLdrOrder::load> Predicate> STATIC_INLINE HMODULE GetModHandle(UNICODE_STRING const& DllName)
            {
                CTX context = {nullptr, DllName};
                NTSTATUS Status = IteratePebLdrDataTable<CTX>(Predicate, context);
                if (NT_SUCCESS(Status))
                {
                    return context.hMod;
                }
                return nullptr;
            }
        } // namespace by_string

        constexpr byte const* checked_cast(byte const* start, byte const* beyond, size_t size)
        {
            if ((beyond <= start) || (start + size >= beyond))
            {
                return nullptr;
            }
            return start;
        }

        template <typename T> constexpr T const* checked_cast(byte const* start, byte const* beyond)
        {
            if (!checked_cast(start, beyond, sizeof(T)))
            {
                return nullptr;
            }
            return reinterpret_cast<T const*>(start);
        }

        // Default to the 64-bit struct, as it is the bigger one
        // NB: takes a pre-populated MapByTrait struct
        STATIC_INLINE constexpr IMAGE_NT_HEADERS64 const* GetImageNtHeaders(by_trait::MapByTrait const& modtraits)
        {
            using byte = unsigned char;
            if (!NT_SUCCESS(modtraits.Status))
            {
                return nullptr;
            }
            byte const* mod = (byte*)modtraits.DllBase;
            byte const* const beyond = mod + modtraits.SizeOfImage;
            auto const* doshdr = checked_cast<IMAGE_DOS_HEADER>(mod, beyond);
            if (!doshdr || (IMAGE_DOS_SIGNATURE != doshdr->e_magic))
            {
                return nullptr;
            }
            auto const* nthdrs = checked_cast<IMAGE_NT_HEADERS64>(mod + doshdr->e_lfanew, beyond);
            if (!nthdrs || (IMAGE_NT_SIGNATURE != nthdrs->Signature))
            {
                return nullptr;
            }
            return nthdrs;
        }
    } // namespace predefined_helpers

    using predefined_helpers::by_trait::GetLdrDataEntryByAddress;
    using predefined_helpers::by_trait::GetLdrDataEntryByModule;
    using predefined_helpers::by_trait::GetModHandleByAddress;

    STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByLoadOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetLdrDataEntryByOrderIndex<PebLdrOrder::load>(Index);
    }

    STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByMemoryOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetLdrDataEntryByOrderIndex<PebLdrOrder::memory>(Index);
    }

    STATIC_INLINE LDR_DATA_TABLE_ENTRY const* GetLdrDataEntryByInitializationOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetLdrDataEntryByOrderIndex<PebLdrOrder::init>(Index);
    }

    STATIC_INLINE HMODULE GetModHandleByLoadOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetModHandleByOrderIndex<PebLdrOrder::load>(Index);
    }
    STATIC_INLINE HMODULE GetModHandleByMemoryOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetModHandleByOrderIndex<PebLdrOrder::memory>(Index);
    }
    STATIC_INLINE HMODULE GetModHandleByInitializationOrderIndex(ULONG Index)
    {
        using namespace predefined_helpers::by_order;
        return GetModHandleByOrderIndex<PebLdrOrder::init>(Index);
    }

    STATIC_INLINE HMODULE GetModHandleByBaseName(UNICODE_STRING const& DllName)
    {
        using namespace predefined_helpers::by_string;
        return GetModHandle<MapByUnicodeString, MapByBaseDllNamePredicate>(DllName);
    }

    STATIC_INLINE HMODULE GetModHandleByFullName(UNICODE_STRING const& DllName)
    {
        using namespace predefined_helpers::by_string;
        return GetModHandle<MapByUnicodeString, MapByFullDllNamePredicate>(DllName);
    }

    STATIC_INLINE HMODULE GetModuleHandleW(LPCWSTR DllName)
    {
        if (!DllName)
        {
            constexpr PebLdrOrder const order = PebLdrOrder::memory;
            auto const* head = GetPebLdrListHead(order);
            auto const* ldrentry = GetLdrDataTableEntry(head, order);
            // Return handle for the module that created the process
            return (HMODULE)ldrentry->DllBase;
        }
        UNICODE_STRING usMod{};
        ntdll::RtlInitUnicodeString(&usMod, DllName);
        HMODULE hMod = GetModHandleByBaseName(usMod);
        if (!hMod)
        {
            hMod = GetModHandleByFullName(usMod);
        }
        return hMod;
    }

    STATIC_INLINE HMODULE GetKernel32()
    {
        constexpr UNICODE_STRING const usKernel32 NTPEBLDR_LITERAL_UNICODE_STRING(L"kernel32.dll");
        return (HMODULE)GetModHandleByBaseName(usKernel32);
    }

    STATIC_INLINE IMAGE_DATA_DIRECTORY const GetDataDirectory(IMAGE_NT_HEADERS64 const* nthdrs, DWORD datadir_index)
    {
        if (!nthdrs)
        {
            return {};
        }
        switch (nthdrs->FileHeader.Machine)
        {
        case IMAGE_FILE_MACHINE_I386:
            {
                auto const* nthdrs32 = (IMAGE_NT_HEADERS32*)nthdrs;
                if (datadir_index < nthdrs32->OptionalHeader.NumberOfRvaAndSizes)
                {
                    return nthdrs32->OptionalHeader.DataDirectory[datadir_index];
                }
            }
        case IMAGE_FILE_MACHINE_AMD64:
            if (datadir_index < nthdrs->OptionalHeader.NumberOfRvaAndSizes)
            {
                return nthdrs->OptionalHeader.DataDirectory[datadir_index];
            }
        }
        return {};
    }

    STATIC_INLINE IMAGE_DATA_DIRECTORY const GetDataDirectory(HMODULE hMod, DWORD datadir_index)
    {
        using namespace predefined_helpers;
        auto const traits = by_trait::GetModTraits(hMod);
        if (!NT_SUCCESS(traits.Status))
        {
            return {};
        }
        auto const* nthdrs = GetImageNtHeaders(traits);
        return GetDataDirectory(nthdrs, datadir_index);
    }

    STATIC_INLINE IMAGE_EXPORT_DIRECTORY const* GetExportDirectory(HMODULE hMod)
    {
        using namespace predefined_helpers;
        auto const traits = by_trait::GetModTraits(hMod);
        if (!NT_SUCCESS(traits.Status))
        {
            return nullptr;
        }
        auto const* nthdrs = GetImageNtHeaders(traits);
        IMAGE_DATA_DIRECTORY const expdatadir = GetDataDirectory(nthdrs, IMAGE_DIRECTORY_ENTRY_EXPORT);

        if (expdatadir.Size && expdatadir.VirtualAddress)
        {
            auto const* const mod = (byte*)traits.DllBase;
            auto const* const modend = mod + traits.SizeOfImage;
            auto const* expdir = checked_cast<IMAGE_EXPORT_DIRECTORY>(&mod[expdatadir.VirtualAddress], modend);
            if (expdir && checked_cast((byte*)expdir, modend, expdatadir.Size))
            {
                return expdir;
            }
        }
        return nullptr;
    }

    STATIC_INLINE FARPROC GetProcAddress(HMODULE hMod, LPCSTR FuncName)
    {
        auto const* expdir = GetExportDirectory(hMod);

        if (!expdir || !FuncName)
        {
            return nullptr;
        }

        auto const* const mod = (byte*)hMod;
        // RVAs to the names of named exports
        auto const* const rvaNames = (ULONG*)&mod[expdir->AddressOfNames];
        // Parallel to the above, contains the index into AddressOfFunctions
        auto const* const rvaNameOrdinals = (USHORT*)&mod[expdir->AddressOfNameOrdinals];
        auto const* const rvaFunctions = (ULONG*)&mod[expdir->AddressOfFunctions];
#if 0
        char const* const modName = (char*)&mod[expdir->Name];
        _tprintf(_T("[%hs] Base: 0x%08X; version: %u.%u\n"),
                 modName,
                 expdir->Base,
                 expdir->MajorVersion,
                 expdir->MinorVersion);
#endif

        if (IS_INTRESOURCE(FuncName))
        {
            USHORT const idx = USHORT((ULONG_PTR)FuncName - expdir->Base);
            if (idx < expdir->NumberOfFunctions)
            {
#if 0
                char const* const ExpFuncName = (char*)&mod[rvaNames[idx]];
                _tprintf(_T("Found ordinal idx %zu: %hs -> RVA:0x%08X\n"),
                            idx,
                            ExpFuncName,
                            rvaFunctions[idx);
#endif
                return (FARPROC)(rvaFunctions[idx] + mod);
            }
        }
        else
        {
            size_t const FuncNameLen = ntdll::crt::strlen_(FuncName);
            for (size_t idx = 0; idx < expdir->NumberOfNames; idx++)
            {
                char const* const ExpFuncName = (char*)mod + rvaNames[idx];
                if (0 == ntdll::crt::strncmp_(FuncName, ExpFuncName, FuncNameLen))
                {
                    auto const addridx = rvaNameOrdinals[idx];
#if 0
                    _tprintf(_T("Found name idx    %zu: %hs -> RVA:0x%08X\n"),
                             idx,
                             ExpFuncName,
                             rvaFunctions[addridx]);
#endif
                    return (FARPROC)(rvaFunctions[addridx] + mod);
                }
            }
        }

        return nullptr;
    }
} // namespace NT

#endif // __NTPEBLDR_H_VER__
